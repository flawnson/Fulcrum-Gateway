# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateOrganizer {
  _count: OrganizerCountAggregate
  _max: OrganizerMaxAggregate
  _min: OrganizerMinAggregate
}

type AggregateQueue {
  _avg: QueueAvgAggregate
  _count: QueueCountAggregate
  _max: QueueMaxAggregate
  _min: QueueMinAggregate
  _sum: QueueSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumQueueStateFieldUpdateOperationsInput {
  set: QueueState
}

input EnumQueueStateFilter {
  equals: QueueState
  in: [QueueState!]
  not: NestedEnumQueueStateFilter
  notIn: [QueueState!]
}

input EnumQueueStateWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumQueueStateFilter
  _min: NestedEnumQueueStateFilter
  equals: QueueState
  in: [QueueState!]
  not: NestedEnumQueueStateWithAggregatesFilter
  notIn: [QueueState!]
}

input EnumUserStatusFieldUpdateOperationsInput {
  set: UserStatus
}

input EnumUserStatusFilter {
  equals: UserStatus
  in: [UserStatus!]
  not: NestedEnumUserStatusFilter
  notIn: [UserStatus!]
}

input EnumUserStatusWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumUserStatusFilter
  _min: NestedEnumUserStatusFilter
  equals: UserStatus
  in: [UserStatus!]
  not: NestedEnumUserStatusWithAggregatesFilter
  notIn: [UserStatus!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  changeStatus: User
  createManyOrganizer(data: [OrganizerCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyQueue(data: [QueueCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOrganizer(data: OrganizerCreateInput!): Organizer!
  createQueue(data: QueueCreateInput!): Queue!
  createUser(data: UserCreateInput!): User!
  deferPosition(id: String!, time: String!): User
  deleteManyOrganizer(where: OrganizerWhereInput): AffectedRowsOutput!
  deleteManyQueue(where: QueueWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOrganizer(where: OrganizerWhereUniqueInput!): Organizer
  deleteQueue(where: QueueWhereUniqueInput!): Queue
  deleteUser(where: UserWhereUniqueInput!): User
  updateManyOrganizer(data: OrganizerUpdateManyMutationInput!, where: OrganizerWhereInput): AffectedRowsOutput!
  updateManyQueue(data: QueueUpdateManyMutationInput!, where: QueueWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOrganizer(data: OrganizerUpdateInput!, where: OrganizerWhereUniqueInput!): Organizer
  updateQueue(data: QueueUpdateInput!, where: QueueWhereUniqueInput!): Queue
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOrganizer(create: OrganizerCreateInput!, update: OrganizerUpdateInput!, where: OrganizerWhereUniqueInput!): Organizer!
  upsertQueue(create: QueueCreateInput!, update: QueueUpdateInput!, where: QueueWhereUniqueInput!): Queue!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumQueueStateFilter {
  equals: QueueState
  in: [QueueState!]
  not: NestedEnumQueueStateFilter
  notIn: [QueueState!]
}

input NestedEnumQueueStateWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumQueueStateFilter
  _min: NestedEnumQueueStateFilter
  equals: QueueState
  in: [QueueState!]
  not: NestedEnumQueueStateWithAggregatesFilter
  notIn: [QueueState!]
}

input NestedEnumUserStatusFilter {
  equals: UserStatus
  in: [UserStatus!]
  not: NestedEnumUserStatusFilter
  notIn: [UserStatus!]
}

input NestedEnumUserStatusWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumUserStatusFilter
  _min: NestedEnumUserStatusFilter
  equals: UserStatus
  in: [UserStatus!]
  not: NestedEnumUserStatusWithAggregatesFilter
  notIn: [UserStatus!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Organizer {
  _count: OrganizerCount!
  id: String!
  name: String!
  password: String
  queues(cursor: QueueWhereUniqueInput, distinct: [QueueScalarFieldEnum!], orderBy: [QueueOrderByWithRelationInput!], skip: Int, take: Int, where: QueueWhereInput): [Queue!]!
}

type OrganizerCount {
  queues: Int!
}

type OrganizerCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  password: Int!
}

input OrganizerCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  password: SortOrder
}

input OrganizerCreateInput {
  id: String
  name: String!
  password: String
  queues: QueueCreateNestedManyWithoutOrganizerInput
}

input OrganizerCreateManyInput {
  id: String
  name: String!
  password: String
}

input OrganizerCreateNestedOneWithoutQueuesInput {
  connect: OrganizerWhereUniqueInput
  connectOrCreate: OrganizerCreateOrConnectWithoutQueuesInput
  create: OrganizerCreateWithoutQueuesInput
}

input OrganizerCreateOrConnectWithoutQueuesInput {
  create: OrganizerCreateWithoutQueuesInput!
  where: OrganizerWhereUniqueInput!
}

input OrganizerCreateWithoutQueuesInput {
  id: String
  name: String!
  password: String
}

type OrganizerGroupBy {
  _count: OrganizerCountAggregate
  _max: OrganizerMaxAggregate
  _min: OrganizerMinAggregate
  id: String!
  name: String!
  password: String
}

type OrganizerMaxAggregate {
  id: String
  name: String
  password: String
}

input OrganizerMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  password: SortOrder
}

type OrganizerMinAggregate {
  id: String
  name: String
  password: String
}

input OrganizerMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  password: SortOrder
}

input OrganizerOrderByWithAggregationInput {
  _count: OrganizerCountOrderByAggregateInput
  _max: OrganizerMaxOrderByAggregateInput
  _min: OrganizerMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  password: SortOrder
}

input OrganizerOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  password: SortOrder
  queues: QueueOrderByRelationAggregateInput
}

input OrganizerRelationFilter {
  is: OrganizerWhereInput
  isNot: OrganizerWhereInput
}

enum OrganizerScalarFieldEnum {
  id
  name
  password
}

input OrganizerScalarWhereWithAggregatesInput {
  AND: [OrganizerScalarWhereWithAggregatesInput!]
  NOT: [OrganizerScalarWhereWithAggregatesInput!]
  OR: [OrganizerScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  password: StringNullableWithAggregatesFilter
}

input OrganizerUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  queues: QueueUpdateManyWithoutOrganizerInput
}

input OrganizerUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
}

input OrganizerUpdateOneRequiredWithoutQueuesInput {
  connect: OrganizerWhereUniqueInput
  connectOrCreate: OrganizerCreateOrConnectWithoutQueuesInput
  create: OrganizerCreateWithoutQueuesInput
  update: OrganizerUpdateWithoutQueuesInput
  upsert: OrganizerUpsertWithoutQueuesInput
}

input OrganizerUpdateWithoutQueuesInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
}

input OrganizerUpsertWithoutQueuesInput {
  create: OrganizerCreateWithoutQueuesInput!
  update: OrganizerUpdateWithoutQueuesInput!
}

input OrganizerWhereInput {
  AND: [OrganizerWhereInput!]
  NOT: [OrganizerWhereInput!]
  OR: [OrganizerWhereInput!]
  id: StringFilter
  name: StringFilter
  password: StringNullableFilter
  queues: QueueListRelationFilter
}

input OrganizerWhereUniqueInput {
  id: String
}

type Query {
  aggregateOrganizer(cursor: OrganizerWhereUniqueInput, orderBy: [OrganizerOrderByWithRelationInput!], skip: Int, take: Int, where: OrganizerWhereInput): AggregateOrganizer!
  aggregateQueue(cursor: QueueWhereUniqueInput, orderBy: [QueueOrderByWithRelationInput!], skip: Int, take: Int, where: QueueWhereInput): AggregateQueue!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstOrganizer(cursor: OrganizerWhereUniqueInput, distinct: [OrganizerScalarFieldEnum!], orderBy: [OrganizerOrderByWithRelationInput!], skip: Int, take: Int, where: OrganizerWhereInput): Organizer
  findFirstQueue(cursor: QueueWhereUniqueInput, distinct: [QueueScalarFieldEnum!], orderBy: [QueueOrderByWithRelationInput!], skip: Int, take: Int, where: QueueWhereInput): Queue
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  groupByOrganizer(by: [OrganizerScalarFieldEnum!]!, having: OrganizerScalarWhereWithAggregatesInput, orderBy: [OrganizerOrderByWithAggregationInput!], skip: Int, take: Int, where: OrganizerWhereInput): [OrganizerGroupBy!]!
  groupByQueue(by: [QueueScalarFieldEnum!]!, having: QueueScalarWhereWithAggregatesInput, orderBy: [QueueOrderByWithAggregationInput!], skip: Int, take: Int, where: QueueWhereInput): [QueueGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  organizer(where: OrganizerWhereUniqueInput!): Organizer
  organizers(cursor: OrganizerWhereUniqueInput, distinct: [OrganizerScalarFieldEnum!], orderBy: [OrganizerOrderByWithRelationInput!], skip: Int, take: Int, where: OrganizerWhereInput): [Organizer!]!
  queue(where: QueueWhereUniqueInput!): Queue
  queues(cursor: QueueWhereUniqueInput, distinct: [QueueScalarFieldEnum!], orderBy: [QueueOrderByWithRelationInput!], skip: Int, take: Int, where: QueueWhereInput): [Queue!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Queue {
  _count: QueueCount!
  address: String!
  average_wait: Int!
  capacity: Int!
  create_time: DateTime!
  grace_period: Int
  id: String!
  join_code: String!
  max_party_size: Int!
  name: String!
  num_abandoned: Int!
  num_deferred: Int!
  num_enqueued: Int!
  num_kicked: Int!
  num_noshow: Int!
  num_serviced: Int!
  offline_time: Int
  organizer: Organizer!
  organizer_id: String!
  state: QueueState!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type QueueAvgAggregate {
  average_wait: Float
  capacity: Float
  grace_period: Float
  max_party_size: Float
  offline_time: Float
}

input QueueAvgOrderByAggregateInput {
  average_wait: SortOrder
  capacity: SortOrder
  grace_period: SortOrder
  max_party_size: SortOrder
  offline_time: SortOrder
}

type QueueCount {
  users: Int!
}

type QueueCountAggregate {
  _all: Int!
  address: Int!
  average_wait: Int!
  capacity: Int!
  create_time: Int!
  grace_period: Int!
  id: Int!
  join_code: Int!
  max_party_size: Int!
  name: Int!
  offline_time: Int!
  organizer_id: Int!
  state: Int!
}

input QueueCountOrderByAggregateInput {
  address: SortOrder
  average_wait: SortOrder
  capacity: SortOrder
  create_time: SortOrder
  grace_period: SortOrder
  id: SortOrder
  join_code: SortOrder
  max_party_size: SortOrder
  name: SortOrder
  offline_time: SortOrder
  organizer_id: SortOrder
  state: SortOrder
}

input QueueCreateInput {
  address: String!
  average_wait: Int!
  capacity: Int!
  create_time: DateTime!
  grace_period: Int
  id: String
  join_code: String!
  max_party_size: Int
  name: String!
  offline_time: Int
  organizer: OrganizerCreateNestedOneWithoutQueuesInput!
  state: QueueState!
  users: UserCreateNestedManyWithoutQueueInput
}

input QueueCreateManyInput {
  address: String!
  average_wait: Int!
  capacity: Int!
  create_time: DateTime!
  grace_period: Int
  id: String
  join_code: String!
  max_party_size: Int
  name: String!
  offline_time: Int
  organizer_id: String!
  state: QueueState!
}

input QueueCreateManyOrganizerInput {
  address: String!
  average_wait: Int!
  capacity: Int!
  create_time: DateTime!
  grace_period: Int
  id: String
  join_code: String!
  max_party_size: Int
  name: String!
  offline_time: Int
  state: QueueState!
}

input QueueCreateManyOrganizerInputEnvelope {
  data: [QueueCreateManyOrganizerInput!]!
  skipDuplicates: Boolean
}

input QueueCreateNestedManyWithoutOrganizerInput {
  connect: [QueueWhereUniqueInput!]
  connectOrCreate: [QueueCreateOrConnectWithoutOrganizerInput!]
  create: [QueueCreateWithoutOrganizerInput!]
  createMany: QueueCreateManyOrganizerInputEnvelope
}

input QueueCreateNestedOneWithoutUsersInput {
  connect: QueueWhereUniqueInput
  connectOrCreate: QueueCreateOrConnectWithoutUsersInput
  create: QueueCreateWithoutUsersInput
}

input QueueCreateOrConnectWithoutOrganizerInput {
  create: QueueCreateWithoutOrganizerInput!
  where: QueueWhereUniqueInput!
}

input QueueCreateOrConnectWithoutUsersInput {
  create: QueueCreateWithoutUsersInput!
  where: QueueWhereUniqueInput!
}

input QueueCreateWithoutOrganizerInput {
  address: String!
  average_wait: Int!
  capacity: Int!
  create_time: DateTime!
  grace_period: Int
  id: String
  join_code: String!
  max_party_size: Int
  name: String!
  offline_time: Int
  state: QueueState!
  users: UserCreateNestedManyWithoutQueueInput
}

input QueueCreateWithoutUsersInput {
  address: String!
  average_wait: Int!
  capacity: Int!
  create_time: DateTime!
  grace_period: Int
  id: String
  join_code: String!
  max_party_size: Int
  name: String!
  offline_time: Int
  organizer: OrganizerCreateNestedOneWithoutQueuesInput!
  state: QueueState!
}

type QueueGroupBy {
  _avg: QueueAvgAggregate
  _count: QueueCountAggregate
  _max: QueueMaxAggregate
  _min: QueueMinAggregate
  _sum: QueueSumAggregate
  address: String!
  average_wait: Int!
  capacity: Int!
  create_time: DateTime!
  grace_period: Int
  id: String!
  join_code: String!
  max_party_size: Int!
  name: String!
  offline_time: Int
  organizer_id: String!
  state: QueueState!
}

input QueueListRelationFilter {
  every: QueueWhereInput
  none: QueueWhereInput
  some: QueueWhereInput
}

type QueueMaxAggregate {
  address: String
  average_wait: Int
  capacity: Int
  create_time: DateTime
  grace_period: Int
  id: String
  join_code: String
  max_party_size: Int
  name: String
  offline_time: Int
  organizer_id: String
  state: QueueState
}

input QueueMaxOrderByAggregateInput {
  address: SortOrder
  average_wait: SortOrder
  capacity: SortOrder
  create_time: SortOrder
  grace_period: SortOrder
  id: SortOrder
  join_code: SortOrder
  max_party_size: SortOrder
  name: SortOrder
  offline_time: SortOrder
  organizer_id: SortOrder
  state: SortOrder
}

type QueueMinAggregate {
  address: String
  average_wait: Int
  capacity: Int
  create_time: DateTime
  grace_period: Int
  id: String
  join_code: String
  max_party_size: Int
  name: String
  offline_time: Int
  organizer_id: String
  state: QueueState
}

input QueueMinOrderByAggregateInput {
  address: SortOrder
  average_wait: SortOrder
  capacity: SortOrder
  create_time: SortOrder
  grace_period: SortOrder
  id: SortOrder
  join_code: SortOrder
  max_party_size: SortOrder
  name: SortOrder
  offline_time: SortOrder
  organizer_id: SortOrder
  state: SortOrder
}

input QueueOrderByRelationAggregateInput {
  _count: SortOrder
}

input QueueOrderByWithAggregationInput {
  _avg: QueueAvgOrderByAggregateInput
  _count: QueueCountOrderByAggregateInput
  _max: QueueMaxOrderByAggregateInput
  _min: QueueMinOrderByAggregateInput
  _sum: QueueSumOrderByAggregateInput
  address: SortOrder
  average_wait: SortOrder
  capacity: SortOrder
  create_time: SortOrder
  grace_period: SortOrder
  id: SortOrder
  join_code: SortOrder
  max_party_size: SortOrder
  name: SortOrder
  offline_time: SortOrder
  organizer_id: SortOrder
  state: SortOrder
}

input QueueOrderByWithRelationInput {
  address: SortOrder
  average_wait: SortOrder
  capacity: SortOrder
  create_time: SortOrder
  grace_period: SortOrder
  id: SortOrder
  join_code: SortOrder
  max_party_size: SortOrder
  name: SortOrder
  offline_time: SortOrder
  organizer: OrganizerOrderByWithRelationInput
  organizer_id: SortOrder
  state: SortOrder
  users: UserOrderByRelationAggregateInput
}

input QueueRelationFilter {
  is: QueueWhereInput
  isNot: QueueWhereInput
}

enum QueueScalarFieldEnum {
  address
  average_wait
  capacity
  create_time
  grace_period
  id
  join_code
  max_party_size
  name
  offline_time
  organizer_id
  state
}

input QueueScalarWhereInput {
  AND: [QueueScalarWhereInput!]
  NOT: [QueueScalarWhereInput!]
  OR: [QueueScalarWhereInput!]
  address: StringFilter
  average_wait: IntFilter
  capacity: IntFilter
  create_time: DateTimeFilter
  grace_period: IntNullableFilter
  id: StringFilter
  join_code: StringFilter
  max_party_size: IntFilter
  name: StringFilter
  offline_time: IntNullableFilter
  organizer_id: StringFilter
  state: EnumQueueStateFilter
}

input QueueScalarWhereWithAggregatesInput {
  AND: [QueueScalarWhereWithAggregatesInput!]
  NOT: [QueueScalarWhereWithAggregatesInput!]
  OR: [QueueScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  average_wait: IntWithAggregatesFilter
  capacity: IntWithAggregatesFilter
  create_time: DateTimeWithAggregatesFilter
  grace_period: IntNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  join_code: StringWithAggregatesFilter
  max_party_size: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  offline_time: IntNullableWithAggregatesFilter
  organizer_id: StringWithAggregatesFilter
  state: EnumQueueStateWithAggregatesFilter
}

enum QueueState {
  ACTIVE
  INACTIVE
  PAUSED
}

type QueueSumAggregate {
  average_wait: Int
  capacity: Int
  grace_period: Int
  max_party_size: Int
  offline_time: Int
}

input QueueSumOrderByAggregateInput {
  average_wait: SortOrder
  capacity: SortOrder
  grace_period: SortOrder
  max_party_size: SortOrder
  offline_time: SortOrder
}

input QueueUpdateInput {
  address: StringFieldUpdateOperationsInput
  average_wait: IntFieldUpdateOperationsInput
  capacity: IntFieldUpdateOperationsInput
  create_time: DateTimeFieldUpdateOperationsInput
  grace_period: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  join_code: StringFieldUpdateOperationsInput
  max_party_size: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  offline_time: NullableIntFieldUpdateOperationsInput
  organizer: OrganizerUpdateOneRequiredWithoutQueuesInput
  state: EnumQueueStateFieldUpdateOperationsInput
  users: UserUpdateManyWithoutQueueInput
}

input QueueUpdateManyMutationInput {
  address: StringFieldUpdateOperationsInput
  average_wait: IntFieldUpdateOperationsInput
  capacity: IntFieldUpdateOperationsInput
  create_time: DateTimeFieldUpdateOperationsInput
  grace_period: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  join_code: StringFieldUpdateOperationsInput
  max_party_size: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  offline_time: NullableIntFieldUpdateOperationsInput
  state: EnumQueueStateFieldUpdateOperationsInput
}

input QueueUpdateManyWithWhereWithoutOrganizerInput {
  data: QueueUpdateManyMutationInput!
  where: QueueScalarWhereInput!
}

input QueueUpdateManyWithoutOrganizerInput {
  connect: [QueueWhereUniqueInput!]
  connectOrCreate: [QueueCreateOrConnectWithoutOrganizerInput!]
  create: [QueueCreateWithoutOrganizerInput!]
  createMany: QueueCreateManyOrganizerInputEnvelope
  delete: [QueueWhereUniqueInput!]
  deleteMany: [QueueScalarWhereInput!]
  disconnect: [QueueWhereUniqueInput!]
  set: [QueueWhereUniqueInput!]
  update: [QueueUpdateWithWhereUniqueWithoutOrganizerInput!]
  updateMany: [QueueUpdateManyWithWhereWithoutOrganizerInput!]
  upsert: [QueueUpsertWithWhereUniqueWithoutOrganizerInput!]
}

input QueueUpdateOneRequiredWithoutUsersInput {
  connect: QueueWhereUniqueInput
  connectOrCreate: QueueCreateOrConnectWithoutUsersInput
  create: QueueCreateWithoutUsersInput
  update: QueueUpdateWithoutUsersInput
  upsert: QueueUpsertWithoutUsersInput
}

input QueueUpdateWithWhereUniqueWithoutOrganizerInput {
  data: QueueUpdateWithoutOrganizerInput!
  where: QueueWhereUniqueInput!
}

input QueueUpdateWithoutOrganizerInput {
  address: StringFieldUpdateOperationsInput
  average_wait: IntFieldUpdateOperationsInput
  capacity: IntFieldUpdateOperationsInput
  create_time: DateTimeFieldUpdateOperationsInput
  grace_period: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  join_code: StringFieldUpdateOperationsInput
  max_party_size: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  offline_time: NullableIntFieldUpdateOperationsInput
  state: EnumQueueStateFieldUpdateOperationsInput
  users: UserUpdateManyWithoutQueueInput
}

input QueueUpdateWithoutUsersInput {
  address: StringFieldUpdateOperationsInput
  average_wait: IntFieldUpdateOperationsInput
  capacity: IntFieldUpdateOperationsInput
  create_time: DateTimeFieldUpdateOperationsInput
  grace_period: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  join_code: StringFieldUpdateOperationsInput
  max_party_size: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  offline_time: NullableIntFieldUpdateOperationsInput
  organizer: OrganizerUpdateOneRequiredWithoutQueuesInput
  state: EnumQueueStateFieldUpdateOperationsInput
}

input QueueUpsertWithWhereUniqueWithoutOrganizerInput {
  create: QueueCreateWithoutOrganizerInput!
  update: QueueUpdateWithoutOrganizerInput!
  where: QueueWhereUniqueInput!
}

input QueueUpsertWithoutUsersInput {
  create: QueueCreateWithoutUsersInput!
  update: QueueUpdateWithoutUsersInput!
}

input QueueWhereInput {
  AND: [QueueWhereInput!]
  NOT: [QueueWhereInput!]
  OR: [QueueWhereInput!]
  address: StringFilter
  average_wait: IntFilter
  capacity: IntFilter
  create_time: DateTimeFilter
  grace_period: IntNullableFilter
  id: StringFilter
  join_code: StringFilter
  max_party_size: IntFilter
  name: StringFilter
  offline_time: IntNullableFilter
  organizer: OrganizerRelationFilter
  organizer_id: StringFilter
  state: EnumQueueStateFilter
  users: UserListRelationFilter
}

input QueueWhereUniqueInput {
  id: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  estimated_wait: Int!
  id: String!
  index: Int!
  join_time: DateTime!
  last_online: DateTime
  name: String!
  party_size: Int!
  password: String
  phone_number: String!
  queue: Queue!
  queue_id: String!
  reneged_time: DateTime
  state: UserStatus!
  summoned: Boolean!
  total_wait: Int
}

type UserAvgAggregate {
  estimated_wait: Float
  index: Float
  party_size: Float
  total_wait: Float
}

input UserAvgOrderByAggregateInput {
  estimated_wait: SortOrder
  index: SortOrder
  party_size: SortOrder
  total_wait: SortOrder
}

type UserCountAggregate {
  _all: Int!
  estimated_wait: Int!
  id: Int!
  index: Int!
  join_time: Int!
  last_online: Int!
  name: Int!
  party_size: Int!
  password: Int!
  phone_number: Int!
  queue_id: Int!
  reneged_time: Int!
  state: Int!
  summoned: Int!
  total_wait: Int!
}

input UserCountOrderByAggregateInput {
  estimated_wait: SortOrder
  id: SortOrder
  index: SortOrder
  join_time: SortOrder
  last_online: SortOrder
  name: SortOrder
  party_size: SortOrder
  password: SortOrder
  phone_number: SortOrder
  queue_id: SortOrder
  reneged_time: SortOrder
  state: SortOrder
  summoned: SortOrder
  total_wait: SortOrder
}

input UserCreateInput {
  estimated_wait: Int!
  id: String
  index: Int!
  join_time: DateTime!
  last_online: DateTime
  name: String!
  party_size: Int
  password: String
  phone_number: String!
  queue: QueueCreateNestedOneWithoutUsersInput!
  reneged_time: DateTime
  state: UserStatus!
  summoned: Boolean
  total_wait: Int
}

input UserCreateManyInput {
  estimated_wait: Int!
  id: String
  index: Int!
  join_time: DateTime!
  last_online: DateTime
  name: String!
  party_size: Int
  password: String
  phone_number: String!
  queue_id: String!
  reneged_time: DateTime
  state: UserStatus!
  summoned: Boolean
  total_wait: Int
}

input UserCreateManyQueueInput {
  estimated_wait: Int!
  id: String
  index: Int!
  join_time: DateTime!
  last_online: DateTime
  name: String!
  party_size: Int
  password: String
  phone_number: String!
  reneged_time: DateTime
  state: UserStatus!
  summoned: Boolean
  total_wait: Int
}

input UserCreateManyQueueInputEnvelope {
  data: [UserCreateManyQueueInput!]!
  skipDuplicates: Boolean
}

input UserCreateNestedManyWithoutQueueInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutQueueInput!]
  create: [UserCreateWithoutQueueInput!]
  createMany: UserCreateManyQueueInputEnvelope
}

input UserCreateOrConnectWithoutQueueInput {
  create: UserCreateWithoutQueueInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutQueueInput {
  estimated_wait: Int!
  id: String
  index: Int!
  join_time: DateTime!
  last_online: DateTime
  name: String!
  party_size: Int
  password: String
  phone_number: String!
  reneged_time: DateTime
  state: UserStatus!
  summoned: Boolean
  total_wait: Int
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  estimated_wait: Int!
  id: String!
  index: Int!
  join_time: DateTime!
  last_online: DateTime
  name: String!
  party_size: Int!
  password: String
  phone_number: String!
  queue_id: String!
  reneged_time: DateTime
  state: UserStatus!
  summoned: Boolean!
  total_wait: Int
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  estimated_wait: Int
  id: String
  index: Int
  join_time: DateTime
  last_online: DateTime
  name: String
  party_size: Int
  password: String
  phone_number: String
  queue_id: String
  reneged_time: DateTime
  state: UserStatus
  summoned: Boolean
  total_wait: Int
}

input UserMaxOrderByAggregateInput {
  estimated_wait: SortOrder
  id: SortOrder
  index: SortOrder
  join_time: SortOrder
  last_online: SortOrder
  name: SortOrder
  party_size: SortOrder
  password: SortOrder
  phone_number: SortOrder
  queue_id: SortOrder
  reneged_time: SortOrder
  state: SortOrder
  summoned: SortOrder
  total_wait: SortOrder
}

type UserMinAggregate {
  estimated_wait: Int
  id: String
  index: Int
  join_time: DateTime
  last_online: DateTime
  name: String
  party_size: Int
  password: String
  phone_number: String
  queue_id: String
  reneged_time: DateTime
  state: UserStatus
  summoned: Boolean
  total_wait: Int
}

input UserMinOrderByAggregateInput {
  estimated_wait: SortOrder
  id: SortOrder
  index: SortOrder
  join_time: SortOrder
  last_online: SortOrder
  name: SortOrder
  party_size: SortOrder
  password: SortOrder
  phone_number: SortOrder
  queue_id: SortOrder
  reneged_time: SortOrder
  state: SortOrder
  summoned: SortOrder
  total_wait: SortOrder
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  estimated_wait: SortOrder
  id: SortOrder
  index: SortOrder
  join_time: SortOrder
  last_online: SortOrder
  name: SortOrder
  party_size: SortOrder
  password: SortOrder
  phone_number: SortOrder
  queue_id: SortOrder
  reneged_time: SortOrder
  state: SortOrder
  summoned: SortOrder
  total_wait: SortOrder
}

input UserOrderByWithRelationInput {
  estimated_wait: SortOrder
  id: SortOrder
  index: SortOrder
  join_time: SortOrder
  last_online: SortOrder
  name: SortOrder
  party_size: SortOrder
  password: SortOrder
  phone_number: SortOrder
  queue: QueueOrderByWithRelationInput
  queue_id: SortOrder
  reneged_time: SortOrder
  state: SortOrder
  summoned: SortOrder
  total_wait: SortOrder
}

enum UserScalarFieldEnum {
  estimated_wait
  id
  index
  join_time
  last_online
  name
  party_size
  password
  phone_number
  queue_id
  reneged_time
  state
  summoned
  total_wait
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  estimated_wait: IntFilter
  id: StringFilter
  index: IntFilter
  join_time: DateTimeFilter
  last_online: DateTimeNullableFilter
  name: StringFilter
  party_size: IntFilter
  password: StringNullableFilter
  phone_number: StringFilter
  queue_id: StringFilter
  reneged_time: DateTimeNullableFilter
  state: EnumUserStatusFilter
  summoned: BoolFilter
  total_wait: IntNullableFilter
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  estimated_wait: IntWithAggregatesFilter
  id: StringWithAggregatesFilter
  index: IntWithAggregatesFilter
  join_time: DateTimeWithAggregatesFilter
  last_online: DateTimeNullableWithAggregatesFilter
  name: StringWithAggregatesFilter
  party_size: IntWithAggregatesFilter
  password: StringNullableWithAggregatesFilter
  phone_number: StringWithAggregatesFilter
  queue_id: StringWithAggregatesFilter
  reneged_time: DateTimeNullableWithAggregatesFilter
  state: EnumUserStatusWithAggregatesFilter
  summoned: BoolWithAggregatesFilter
  total_wait: IntNullableWithAggregatesFilter
}

enum UserStatus {
  ABANDONED
  DEFERRED
  ENQUEUED
  KICKED
  NOSHOW
  SERVICED
}

type UserSumAggregate {
  estimated_wait: Int
  index: Int
  party_size: Int
  total_wait: Int
}

input UserSumOrderByAggregateInput {
  estimated_wait: SortOrder
  index: SortOrder
  party_size: SortOrder
  total_wait: SortOrder
}

input UserUpdateInput {
  estimated_wait: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  index: IntFieldUpdateOperationsInput
  join_time: DateTimeFieldUpdateOperationsInput
  last_online: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  party_size: IntFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  phone_number: StringFieldUpdateOperationsInput
  queue: QueueUpdateOneRequiredWithoutUsersInput
  reneged_time: NullableDateTimeFieldUpdateOperationsInput
  state: EnumUserStatusFieldUpdateOperationsInput
  summoned: BoolFieldUpdateOperationsInput
  total_wait: NullableIntFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  estimated_wait: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  index: IntFieldUpdateOperationsInput
  join_time: DateTimeFieldUpdateOperationsInput
  last_online: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  party_size: IntFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  phone_number: StringFieldUpdateOperationsInput
  reneged_time: NullableDateTimeFieldUpdateOperationsInput
  state: EnumUserStatusFieldUpdateOperationsInput
  summoned: BoolFieldUpdateOperationsInput
  total_wait: NullableIntFieldUpdateOperationsInput
}

input UserUpdateManyWithWhereWithoutQueueInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithoutQueueInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutQueueInput!]
  create: [UserCreateWithoutQueueInput!]
  createMany: UserCreateManyQueueInputEnvelope
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutQueueInput!]
  updateMany: [UserUpdateManyWithWhereWithoutQueueInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutQueueInput!]
}

input UserUpdateWithWhereUniqueWithoutQueueInput {
  data: UserUpdateWithoutQueueInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithoutQueueInput {
  estimated_wait: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  index: IntFieldUpdateOperationsInput
  join_time: DateTimeFieldUpdateOperationsInput
  last_online: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  party_size: IntFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  phone_number: StringFieldUpdateOperationsInput
  reneged_time: NullableDateTimeFieldUpdateOperationsInput
  state: EnumUserStatusFieldUpdateOperationsInput
  summoned: BoolFieldUpdateOperationsInput
  total_wait: NullableIntFieldUpdateOperationsInput
}

input UserUpsertWithWhereUniqueWithoutQueueInput {
  create: UserCreateWithoutQueueInput!
  update: UserUpdateWithoutQueueInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  estimated_wait: IntFilter
  id: StringFilter
  index: IntFilter
  join_time: DateTimeFilter
  last_online: DateTimeNullableFilter
  name: StringFilter
  party_size: IntFilter
  password: StringNullableFilter
  phone_number: StringFilter
  queue: QueueRelationFilter
  queue_id: StringFilter
  reneged_time: DateTimeNullableFilter
  state: EnumUserStatusFilter
  summoned: BoolFilter
  total_wait: IntNullableFilter
}

input UserWhereUniqueInput {
  id: String
}
